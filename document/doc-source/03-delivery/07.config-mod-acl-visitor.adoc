ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

===== 3.7.1.4.资源访问者（Visitor）

[TIP]
====
多用于抽象层次比较高的 *动态建模* 领域的权限控制。
====

本章进入Zero权限框架中的一个新的领域：*虚拟资源/资源访问者*，在讲虚拟资源之前先思考：为什么要使用虚拟资源？前文安全视图中的定义不知道读者是否发现一个小问题：静态的——一旦绑定了资源之后，就只能在某个资源中直接设置参数和条件，而这里设置的所有条件以及参数都 *不依赖输入*，您考虑下边一个场景。

我在后端书写了一个接口：`/api/xxx/:type`，这个接口在后端的定义的接口和 `S_RESOURCE` 记录仅有一条（为什么，除非您直接愿意写成 `/api/xxx/type1` 和 `/api/xxx/type2` 两个接口），这种场景下，意味着如果`type`有三个值，那么我所期望的安全视图应该有三种，根据前文提到的，您可以设置 `S_VIEW` 的 `POSITION` 来限定资源视图，就完成了三种模式下的定义。但若现在我的 `:type` 参数不是三种，可能存在N种或者上百种，如何解决？Zero为了解决这种安全视图方案，提供了 *资源访问者* 的概念。资源访问者存储于后端配置表 `S_VISITANT` 中，一个 `S_VIEW`（严格说是 VISITANT = true 的视图记录）可能包含无数个资源访问者。

Zero中按照如下流程配置一个资源访问者：

1. 资源本身（`S_RESOURCE`）将该资源定义成一个虚拟资源（`VIRTUAL` = true）。
2. 在（`S_RESOURCE`）资源字段中定义访问者基本规则：

+
--
    - 设置访问者语法 `SEEK_SYNTAX` 字段。
    - 设置访问者配置 `SEEK_CONFIG` 字段。
    - 设置访问者组件 `SEEK_COMPONENT` 字段（Java类名）。
--
3. 用户发送请求过来时会读取 `S_VIEW` 的视图信息，一旦读取到视图信息后，对 `VISITANT` = true执行校验，校验成功之后执行资源访问者流程。

资源访问者流程可以总结成两个大步骤：

[options="header"]
|====
|步骤|说明
|真实资源查找|根据 `S_RESOURCE` 中的 `VIRTUAL = true` 的定义去查找真实资源，真实资源的查找就借用访问者配置（前文提到的基本规则）来实现。
|访问者安全视图|工具 `S_VIEW` 中的 `VISITANT = true` 的定义去同步查找真实资源模式下的安全视图，该视图比 `S_VIEW` 中扩展的属性更多，渗透到表单级、操作级、非接口级，数据更强大的ACL控制视图逻辑。
|====

====== 访问者逻辑

资源访问者的内部逻辑流程如下：

1. 检查访问视图 `S_VIEW` 是否一个带有访问者的安全视图（`VISITANT = true`）的定义。
2. 根据资源 `S_RESOURCE` 中的访问者定义（`seekSyntax / seekConfig / seekComponent`）计算真实资源访问规则。
3. 扫描资源访问者的 *模式*（Replace/Extend）和 *作用阶段*（EAGER/DELAY），并执行访问者操作。
4. 读取访问者相关信息，将这些信息和 `S_VIEW` 中的信息合并计算，计算访问者安全窗口。

====== （执行维度）模式和阶段

资源访问者语法中的模式 mode 信息：

- Replace：替换模式，这种模式下，访问者视图会直接覆盖 `S_VIEW` 中的安全窗口规则，也就是说资源访问不再遵循 `S_VIEW` 中的安全规则，而直接使用访问者规则。
- Extend：扩展模式，这种模式下，访问者视图会和 `S_VIEW` 中的安全窗口规则合并计算，形成新的组合好的访问者规则。

资源访问者语法中的阶段 phase 信息：

- EAGER：通常当前资源立即生效，一般执行数据读取时会使用 EAGER 阶段（就在当前接口生效）。
- DELAY：这种阶段通常是读取配置项作用于子资源或其他资源时生效，一般读取元数据和配置数据时使用 DELAY 阶段（DELAY阶段 DataRegion 中的视图模式依旧生效）。

====== （定义维度）类型/标识/唯一键

执行资源访问者需要具备两个条件：`S_RESOURCE` 中的执行维度、`S_VIEW` 中的定义维度，而定义维度就是依赖参数去查找当前 `S_VIEW` 中所拥有的众多资源访问者中的其中