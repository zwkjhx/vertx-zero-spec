ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

===== 3.7.1.4.资源访问者（Visitor）

[TIP]
====
多用于抽象层次比较高的 *动态建模* 领域的权限控制。
====

本章进入Zero权限框架中的一个新的领域：*虚拟资源/资源访问者*，在讲虚拟资源之前先思考：为什么要使用虚拟资源？前文安全视图中的定义不知道读者是否发现一个小问题：静态的——一旦绑定了资源之后，就只能在某个资源中直接设置参数和条件，而这里设置的所有条件以及参数都 *不依赖输入*，您考虑下边一个场景。

我在后端书写了一个接口：`/api/xxx/:type`，这个接口在后端的定义的接口和 `S_RESOURCE` 记录仅有一条（为什么，除非您直接愿意写成 `/api/xxx/type1` 和 `/api/xxx/type2` 两个接口），这种场景下，意味着如果`type`有三个值，那么我所期望的安全视图应该有三种，根据前文提到的，您可以设置 `S_VIEW` 的 `POSITION` 来限定资源视图，就完成了三种模式下的定义。但若现在我的 `:type` 参数不是三种，可能存在N种或者上百种，如何解决？Zero为了解决这种安全视图方案，提供了 *资源访问者* 的概念。资源访问者存储于后端配置表 `S_VISITANT` 中，一个 `S_VIEW`（严格说是 VISITANT = true 的视图记录）可能包含无数个资源访问者。

image:zero-p-visit-arch.png[,800]


[NOTE]
====
从上图可以知道在动态建模过程中，*路由器* 和 *防火墙* 可能意味着不同模型，而且应用程序会不断添加新的设备类型，产生新的模型，这种模式下使用 `POSITION` 扩展会造成大量冗余，况且此时的入口是虚拟资源，即意味着：您在访问该资源时，您是不知道您访问的资源究竟是路由器还是防火墙，那么这样的流程中，就只能通过 *访问者* 语法计算出真实访问者，然后根据资源访问者去定位真实的资源。从这点意义上讲您可以理解两点：

- `POSITION`：先知模式，在访问资源之前，您已经知道您要访问的维度数据是什么，资源访问入口是具象层。
- `VISITANT`：后知模式，在访问资源之前，您不知道您要访问的维度数据是什么，资源访问入口是抽象层（这也是虚拟资源一词的来源）。
====

Zero中按照如下流程配置一个资源访问者：

1. 资源本身（`S_RESOURCE`）将该资源定义成一个虚拟资源（`VIRTUAL` = true）。
2. 在（`S_RESOURCE`）资源字段中定义访问者基本规则：

+
--
    - 设置访问者语法 `SEEK_SYNTAX` 字段。
    - 设置访问者配置 `SEEK_CONFIG` 字段。
    - 设置访问者组件 `SEEK_COMPONENT` 字段（Java类名）。
--
3. 用户发送请求过来时会读取 `S_VIEW` 的视图信息，一旦读取到视图信息后，对 `VISITANT` = true执行校验，校验成功之后执行资源访问者流程。

资源访问者流程可以总结成两个大步骤：

[options="header"]
|====
|步骤|说明
|真实资源查找|根据 `S_RESOURCE` 中的 `VIRTUAL = true` 的定义去查找真实资源，真实资源的查找就借用访问者配置（前文提到的基本规则）来实现。
|访问者安全视图|工具 `S_VIEW` 中的 `VISITANT = true` 的定义去同步查找真实资源模式下的安全视图，该视图比 `S_VIEW` 中扩展的属性更多，渗透到表单级、操作级、非接口级，数据更强大的ACL控制视图逻辑。
|====

====== 访问者逻辑

资源访问者的内部逻辑流程如下：

1. 检查访问视图 `S_VIEW` 是否一个带有访问者的安全视图（`VISITANT = true`）的定义。
2. 根据资源 `S_RESOURCE` 中的访问者定义（`seekSyntax / seekConfig / seekComponent`）计算真实资源访问规则。
3. 扫描资源访问者的 *模式*（Replace/Extend）和 *作用阶段*（EAGER/DELAY），并执行访问者操作。
4. 读取访问者相关信息，将这些信息和 `S_VIEW` 中的信息合并计算，计算访问者安全窗口。

关于访问者语法结构定义在此多做点说明，在实际场景中，通常资源的抽象模式（访问者维度）都只有一个维度，所以访问者语法也只是针对资源的访问做一个维度层面的拓展，若您的应用中真的出现了 *超级接口*，访问者维度需要通过多维模式去实现时，您可以自定义扩展：

- 单维度标准化：`seekSyntax`定义可完成。
- 多维度标准化：`seekSyntax`新版多维访问者定义完成。
- 多维度扩展：`seekConfig/seekComponent`自定义完成。

个人不推荐在系统中做过多的 *超级接口* ——一个接口完成多种不同的逻辑，这样的方式运维将会造成一定的压力，并且不容易拓展，但在动态建模和动态接口部分，往往会牵涉到模型的变体，变体出现时这种模式的维度是必须存在的，所以就只能依赖扩展配置来完成。


[CAUTION]
====
多说一句：Zero扩展框架中存在很多 `config/component` 的架构，通常 `component` 是一个实现了固定接口的Java类，而 `config` 则是和该类配套的配置数据（Json格式），这样的格式可以让任何开发人员自由发挥拓展自己的应用，访问者逻辑部分也是如此。
====

*访问者语法* 存在的目的是查找视图中对应的访问者信息，由于一个视图可能存在多个访问者，所以系统必须保证本次请求的访问者信息——要么只有1个，要么不存在；否则系统会出现二义性问题导致最终无法定位使用哪个资源访问者来处理请求，所以目前Zero权限框架的版本中，访问者主键 `S_VISITANT` 表中的 `SEEK_KEY` 字段是唯一的，而访问者语法的最终目的就是计算 `SEEK_KEY` 生成访问者查询条件。

====== （执行维度）模式和阶段

资源访问者语法中的模式 mode 信息（ `S_VISITANT` 表中的 `MODE` 字段）：

- Replace：替换模式，这种模式下，访问者视图会直接覆盖 `S_VIEW` 中的安全窗口规则，也就是说资源访问不再遵循 `S_VIEW` 中的安全规则，而直接使用访问者规则。
- Extend：扩展模式，这种模式下，访问者视图会和 `S_VIEW` 中的安全窗口规则合并计算，形成新的组合好的访问者规则。

它的作用如下：

image:zero-p-visit-mode.png[,800]

资源访问者语法中的阶段 phase 信息（ `S_VISITANT` 表中的 `PHASE` 字段）：

- EAGER：通常当前资源立即生效，一般执行数据读取时会使用 EAGER 阶段（就在当前接口生效）。
- DELAY：这种阶段通常是读取配置项作用于子资源或其他资源时生效，一般读取元数据和配置数据时使用 DELAY 阶段（DELAY阶段 DataRegion 中的视图模式依旧生效）。

它的作用如下：

image:zero-p-visit-phase.png[,800]

[CAUTION]
====
对于直接开发的接口，基本上EAGER模式就可以满足大量的接口安全控制需求，您不需要开发额外的逻辑就实现了安全视图的控制，但对于比较特殊的基于配置的流程中，通常接口会分为：元数据接口和数据接口两部分，二者相互影响并相互作用，这样的条件下，资源访问者就体现出它的价值了，一个访问者就解决了元数据接口和数据接口的双重安全作用，而不需要依赖每个位置都定义对应的接口。
====

====== （定义维度）类型/标识/唯一键

访问者记录中虽然保存了 `SEEK_KEY`，但在不同的业务场景中，它无法做 *全局标识*，所以根据实际需求，此处设计在后期做过一些基本改动，访问者标识维度如下：

[options="header"]
|====
|字段|含义
|TYPE|访问者类型，针对资源维度的分类定义，现阶段支持：FORM、LIST、OP、VIEW 四种，服务于 `zero-atom` 动态建模。
|IDENTIFIER|模型标识符，针对模型维度的分类定义，主要提供master模型的基础访问者（限定于所有场景）。
|SEEK_KEY|访问者主键，系统可以根据访问者主键查询访问者信息。
|====

访问者标识维度从执行和定义两个方向处理：

1. 定义维度：`VIEW_ID, TYPE, IDENTIFIER` 形成唯一键。
2. 执行维度：`VIEW_ID, TYPE, SEEK_KEY` 形成唯一键。

[NOTE]
====
举个例子，在读取表单配置时，表单的配置可直接使用：`VIEW_ID,TYPE,SEEK_KEY`限定：

- `VIEW_ID` ：标识了读取表单的资源接口信息。
- `TYPE` ：手动定义，静态模式下使用固定值，动态模式中则可以直接使用限定值。
- `SEEK_KEY` ：根据表单计算这种类型的主键，此时它的值可以是表单的ID（动态），也可以是表单的CODE（静态）。

这样处理之后就实现了表单资源的唯一访问者读取。

====

`SEEK_KEY` 目前最常用的两种场景如：

1. 动态建模过程中，资源访问会牵涉 `controlId`（表单、列表的组件ID），它的格式通常如下：

+
[source,json]
----
{
    "type": "LIST / FORM / OP",
    "controlId": "UI_CONTROL表中定义的组件的ID，由于UI_CONTROL中已经定义了模型标识符，所以此处模型标识符则可直接省略。"
}
----

2. 静态建模过程中，资源访问者会牵涉到其他内容来构造 `SEEK_KEY`，如：

+
[source,json]
----
{
    "type": "LIST / FORM /OP",
    "workflow": "工作流名称"
}
----

[TIP]
====
现在版本中的流程 `SEEK_KEY` 的值格式通常是：`:workflow/:event/DEFAULT` ，其中包含了流程名称和任务名称，这样就可以保证流程中的每个节点都可设置访问者，配合 `TYPE` 字段实现列表、表单、操作不同级别的访问。
====

====== 访问控制

访问者对列表的控制基本和 `S_VIEW` 同源，主要覆盖如下：

[options="header"]
|====
|字段|含义
|DM_ROW|等价于视图中的 ROWS 限定规则，前端标记：H - Horizon，水平限定。
|DM_QR|等价于视图中的 CRITERIA 限定规则，前端标记：Q - Query，查询限定。
|DM_COLUMN|等价于视图中的 PROJECTION 限定规则，前端标记：V - Vertical，垂直限定。
|====

访问者优于视图的地方在于它还提供了表单级的控制，主要覆盖如下：

[options="header"]
|====
|字段|关键字|含义
|ACL_VISIBLE|可见性|可见属性集设置，限定表单中的某些表单字段是否可见。
|ACL_VIEW|只读|只读属性集设置，可编辑依靠计算：`可见性 - 只读`。
|*ACL_VARIETY|多样性|多样性属性集设置，用于控制集合类型的属性变体，如数组类的多样性属性集，递归三种属性集，标记某个子属性配置。
|ACL_VOW|引用|针对引用类型的属性进行限定，比如订单中关联了员工信息，而员工信息可直接被订单接口的访问者执行表单级属性过滤。
|ACL_VERGE|依赖|保存了所有依赖属性的相关信息，和引用方向相反。
|====

[CAUTION]
====
上述属性中 ACL_VARIETY 属于特殊访问属性，通常可针对列表、集合等不同的访问属性进行内部数据结构的限定，有了这些限定之后，不同的用户在访问同一张表单可达到如下权限控制效果：

- 访问的表单长相不同（可见性处理）。
- 访问同样的表单部分属性看见的内容不同，包括只读、可编辑。
- 表单引入：有值不可看的情况，这种情况下表单中会显示 ******** 来处理（仅针对特殊角色和用户生效）。
- 依赖属性的不可见处理，所有和表单关联的数据出现不可看的情况。

====












