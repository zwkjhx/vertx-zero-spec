ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

===== 3.7.1.3.N维安全视图（View）

前文解决了资源 *能不能* 访问的问题，本章就在可访问的基础上解决 *访问多少* 的问题，Zero权限框架中的 `S_RESOURCE` 和 `S_ACTION` 是强绑定关系，它们之间只会单纯对比操作级别和资源需求级别是否可访问，一旦访问成功，就会延生读写操作的边界，在Zero权限框架中读写边界的划定取决于安全视图 `S_VIEW` 中的定义。

====== 安全视图基础

安全视图的基础维度如下：

[options="header"]
|====
|字段名|含义|取值
|NAME|视图名称|默认取值 DEFAULT。
|POSITION|视图位置|默认取值 DEFAULT。
|OWNER_TYPE|视图所属|只包含两种：ROLE-角色视图，USER-用户视图。
|OWNER|视图所属者ID|如果是角色视图则是角色ID，如果是用户视图则是用户ID。
|RESOURCE_ID|视图所属资源|当前视图关联的 `S_RESOURCE` 资源ID，一个资源可能存在多个安全视图。
|====

[NOTE]
====
POSITION 和 NAME 构造的视图的核心维度，在系统出现不同需求时会起重要作用：

[options="header"]
|====
|场景|NAME|POSITION
|单模块无视图管理|DEFAULT|DEFAULT
|单模块带视图|?|DEFAULT
|多模块无视图管理|DEFAULT|?
|多模块多视图管理|?|?
|====

此处解释一下模块的概念，此处的 *模块* 并非我们开发过程中的模块，此处的模块底层关联模型只有一个，而模块更多是从列表作为入口。例如：

- 单纯的CRUD应用（角色管理），可能不带模块概念，管理过程中它的模块只有一个，从角色列表进入，然后管理。
- 带分类的CRUD应用（订单管理），可能带有不同列表管理处理，如正在执行的订单模块、已经完成的订单模块，而此时后台关联的模型依旧是 *订单*，这种情况下 POSITION 就显得很重要。

而且 POSITION 会比资源多一个维度，通常资源是后接口绑定，如 `/api/xxx/search` 的资源接口，但这个资源接口由于支持查询引擎语法，可能应用于不同的菜单入口（上述提到的正在执行的订单、已完成的订单）等，这种情况下两个菜单共享了一个资源，而为了针对不同的菜单定义 *角色视图/用户视图*，最好的方式就是启用 POSITION 参数。如此计算下来，POSITION既不和查询条件绑定（不同页面、不同位置、同一查询条件），也不可以和页面绑定，如果出现 `TAB` 页签会造成同一个页面中出现两种不同的查询（可能是两种不同的 POSITION），最终它只能和列表的配置绑定，直接在前端中提供它的配置来完成和列表绑定的过程，这一块的用法属于 Zero权限框架中的难点，其应用范围十分广泛，现阶段通常使用场景如下：

- 按类型划分位置信息：分类字段管理 `/ambient/tabular/:type` 不同页面取不同的 POSITION，实现抽象态的列表管理，这种思路同样适用于：档案、合同、项目、员工、客户、分类等。
- 按类型划分位置信息：如待办列表和已办列表，最终访问资源可能都是 `/api/todo/search`，而由于状态不同，所以设置不同的 POSITION 实现视图的定制。
- 按流程划分QBE：目前系统中流程右上角的QBE列表页是基于此种逻辑，几乎不使用开发的模式就定制完成。

====

====== 安全视图类

Zero中存在一个特殊的参数对象：

[source,java]
----
    public class Vis extends JsonObject

    // 该参数对象使用时可如下：
    @POST
    @Path("/{actor}/search")
    @Address(Addr.Post.SEARCH)
    @Adjust(Orders.MODULE)
    JsonObject search(@PathParam("actor") String actor,
                      @BodyParam JsonObject data,
                      @QueryParam(KName.MODULE) String module,
                      @PointParam(KName.VIEW) Vis view);
----

该参数的格式比较特殊，通常使用的是　`[view,position]` 的数据格式，也是此处的 `@PointParam` 注解解析的内容，它可以将上述格式直接解析成视图的两个核心维度（ `NAME, POSITION` ），并将该维度应用于任意支持它的接口。

====== 窗口定义

安全视图的窗口定义主要依靠下边几个字段：

[options="header"]
|====
|字段名|含义
|PROJECTION|JsonArray格式，执行该视图的列过滤，直接过滤掉接口返回数据的列信息。
|CRITERIA|JsonObject格式，执行该视图默认的 `Qr` 语法注入，启用查询引擎追加接口的查询条件语法。
|ROWS|JsonObject格式，针对行数据执行筛选，生成 `IN` 语句筛选特定行，通常是查询引擎无法做细粒度筛选时的一种折中选择。
|VISITANT|布尔值，是否启用 *虚拟视图（资源访问者）*。
|====

- `PROJECTION` 会作用于不同类型的前端组件，通常用于 `LIST/FORM` 两种，Zero框架中的保存列表的列信息以及表单中针对部分表单执行字段过滤就依赖它来完成，它是后置过滤（实际会从数据库中查询出所有信息进行值提取，现阶段没有明显的性能问题）。
- `CRITERIA` 主要针对于查询，它会隐式修改查询引擎的 `Qr` 语法，导致前端发送查询条件在安全视图作用下被直接修改，如果用户中出现了多个角色、多个用户组，则按照最终资源需求中定义的 Profile 来完成查询条件的拼合，默认模式下多个角色之间使用 `OR` 连接符。
- `ROWS` 针对特殊资源提取，提供基于主键的直接命中条件，解决异构查询模式下用户无法使用Join的情况，由于表单是单条数据记录，所以一般表单接口无法支持该属性（设置了也没有效果）；通常此属性作用于列表：

+
--
    - DATA：在数据层面，列表处理过程中直接针对条件执行过滤，典型应用为：菜单筛选、字典筛选、分类树筛选。
    - META：元数据层面，处理过程中只读取ROWS中设置过的的信息（特殊模式下载界面呈现模式出现ReadOnly时，它的定义位于UI配置中，而不是安全视图层。
--

[CAUTION]
====
虚拟视图（资源访问者）部分参考下一个章节的详细说明，上述限制中，虽然 `ROWS` 无法直接作用于表单属性级的过滤窗口操作，但是它可以实现动态表单（`/api/ui/form`）模式下的属性集过滤，比如读取表单的属性有25个，使用 `ROWS`直接过滤掉一部分留下一部分，最终输出的是配置、配置、配置，最终表单引擎根据配置渲染表单，可以完成间接作用流程。
====

====== 视图检索流程

看完了上述安全视图的方方面面之后，视图检索流程就变得异常简单了，后端会根据访问资源键值生成 `session-<METHOD>:<URI>:<POSITION>/<VIEW>` 格式的视图缓存键，下边是用户访问某个资源接口时的详细流程：

1. 用户发送请求到某个资源接口如：`/api/xxx/resource`。
2. 系统检索该资源是否存在用户级的 `S_VIEW` 记录（`OWNER_TYPE = USER, OWNER = <USER_ID>`），如果存在该记录，则直接提取安全视图记录对资源执行前后（BEFORE/AFTER）计算。
3. 若不存在用户级的 `S_VIEW` 记录，则继续检索是否有角色级的 `S_VIEW` 记录，若存在则计算。
4. 上述两步都不存在时，忽略安全视图，可访问所有内容。

[TIP]
====
从上述流程可以知道，用户级安全视图优先级比角色高，一般用户级安全视图都是个人视图模式存在，比如某个模块的视图管理，而角色级的视图都是管理员预设，单个用户不可以更改，比如管理员直接针对财务人员以外的角色设置不可访问某些资源的固定列如薪资、账期等。
====

最终 *访问多少* 的问题就直接被安全视图处理掉了，不同角色不同用户在此框架之下访问同一个接口时返回数据就可能出现不同，那么这样就解决了资源重用并且 *访问多少* 的问题。